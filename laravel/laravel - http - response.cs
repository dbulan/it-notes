# LARAVEL - HTTP - RESPONSE

Eloquent model automatically be converted to JSON. 

# Attaching Headers To Responses

return response($content)
			->header('Content-Type', $type)
			->header('X-Header-One', 'Header Value')
			->header('X-Header-Two', 'Header Value');

// OR //
return response($content)
			->withHeaders([
				'Content-Type' => $type,
				'X-Header-One' => 'Header Value',
				'X-Header-Two' => 'Header Value',
			]);
			
# Cache Control Middleware

Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function () {
    Route::get('/privacy', function () {
        // ...
    });

    Route::get('/terms', function () {
        // ...
    });
});

# Attaching Cookies To Responses

return response('Hello World')->cookie(
    'name', 'value', $minutes
);


// If you would like to ensure that a cookie is sent with the outgoing response but you do not yet have an instance of that response, 
// you can use the Cookie facade to "queue" cookies for attachment to the response when it is sent.

Cookie::queue('name', 'value', $minutes);

// If you would like to generate a instance that can be attached to a response instance at a later time, you may use the global cookie helper. 
// This cookie will not be sent back to the client unless it is attached to a response instance:

$cookie = cookie('name', 'value', $minutes);

return response('Hello World')->cookie($cookie);

# Expiring Cookies Early

return response('Hello World')->withoutCookie('name');
// If you do not yet have an instance of the outgoing response //
Cookie::expire('name');

# Cookies & Encryption
// By default, all cookies generated by Laravel are encrypted and signed so that they can't be modified or read by the client. 
// If you would like to disable encryption for a subset of cookies generated by your application, you may use the $except property of the  middleware, which is located in the app/Http/Middleware directory:

protected $except = [
    'cookie_name',
];

# ---------- Redirects

// Sometimes you may wish to redirect the user to their previous location, such as when a submitted form is invalid.
// You may do so by using the global back helper function. Since this feature utilizes the session, make sure the route calling the back function is using the web middleware group:

Route::post('/user/profile', function () {
    // Validate the request...

    return back()->withInput();
});

// Redirecting To Named Routes

return redirect()->route('login');

// Redirecting To Controller Actions

return redirect()->action([UserController::class, 'index']);
return redirect()->action([UserController::class, 'profile'], ['id' => 1]);

// Redirecting To External Domains

return redirect()->away('https://www.google.com');

// Redirecting With Flashed Session Data

Route::post('/user/profile', function () {
    return redirect('dashboard')->with('status', 'Profile updated!');
});

@if (session('status'))
    <div class="alert alert-success">
        {{ session('status') }}
    </div>
@endif

# Redirecting With Input

// You may use the withInput method provided by the RedirectResponse instance to flash the current request's input data to the session before redirecting the user to a new location.

return back()->withInput();